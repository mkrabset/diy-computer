/usr/local/java/jdk/bin/java -javaagent:/usr/local/java/idea-IU-183.4886.37/lib/idea_rt.jar=45385:/usr/local/java/idea-IU-183.4886.37/bin -Dfile.encoding=UTF-8 -classpath /usr/local/java/jdk/jre/lib/charsets.jar:/usr/local/java/jdk/jre/lib/deploy.jar:/usr/local/java/jdk/jre/lib/ext/cldrdata.jar:/usr/local/java/jdk/jre/lib/ext/dnsns.jar:/usr/local/java/jdk/jre/lib/ext/jaccess.jar:/usr/local/java/jdk/jre/lib/ext/jfxrt.jar:/usr/local/java/jdk/jre/lib/ext/localedata.jar:/usr/local/java/jdk/jre/lib/ext/nashorn.jar:/usr/local/java/jdk/jre/lib/ext/sunec.jar:/usr/local/java/jdk/jre/lib/ext/sunjce_provider.jar:/usr/local/java/jdk/jre/lib/ext/sunpkcs11.jar:/usr/local/java/jdk/jre/lib/ext/zipfs.jar:/usr/local/java/jdk/jre/lib/javaws.jar:/usr/local/java/jdk/jre/lib/jce.jar:/usr/local/java/jdk/jre/lib/jfr.jar:/usr/local/java/jdk/jre/lib/jfxswt.jar:/usr/local/java/jdk/jre/lib/jsse.jar:/usr/local/java/jdk/jre/lib/management-agent.jar:/usr/local/java/jdk/jre/lib/plugin.jar:/usr/local/java/jdk/jre/lib/resources.jar:/usr/local/java/jdk/jre/lib/rt.jar:/home/ivark/projects/diy-computer/server/out/production/classes:/home/ivark/projects/diy-computer/server/out/production/resources:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter-web/1.5.9.RELEASE/bda9733d5e6ba6d1a97deead1738713dc0631b3e/spring-boot-starter-web-1.5.9.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter-jersey/1.5.9.RELEASE/f7be1e712bee3e06e8b28fed4e7a844a08b9efab/spring-boot-starter-jersey-1.5.9.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.scream3r/jssc/2.8.0/7e8d93052a8743a7937a6d46854057ac1ce876c1/jssc-2.8.0.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.rxtx/rxtx/2.1.7/e96c946be1e6537378fd532d2742b523df2725a4/rxtx-2.1.7.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.datatype/jackson-datatype-jsr310/2.8.3/cfc4a64ecdb762d39c5d24823ed079df261562c4/jackson-datatype-jsr310-2.8.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.module/jackson-module-kotlin/2.8.3/e90081bf64336ff0bdf2600131ec7aa65c5f028c/jackson-module-kotlin-2.8.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.media/jersey-media-json-jackson/2.25.1/19d1e4276eb7b6386640c344d9e5c01eba7eae5d/jersey-media-json-jackson-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.jaxrs/jackson-jaxrs-json-provider/2.8.7/3d6ac461d0b478c85ca380468f675c7217295591/jackson-jaxrs-json-provider-2.8.7.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.jaxrs/jackson-jaxrs-base/2.8.7/814af809cd9fca86e9d89c17080bb0446b06569d/jackson-jaxrs-base-2.8.7.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.module/jackson-module-jaxb-annotations/2.8.7/4d7e1de1694d9f95eada828dabf43121b3afc435/jackson-module-jaxb-annotations-2.8.7.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-databind/2.8.3/cea3788c72271d45676ce32c0665991674b24cc5/jackson-databind-2.8.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-core/2.8.3/5e1dc37c96308851c3ff609c250dc849c4b12022/jackson-core-2.8.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter-validation/1.5.2.RELEASE/2eb3cf38e0ab2611f305626ea5dc96619ddadc1d/spring-boot-starter-validation-1.5.2.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter/1.5.2.RELEASE/c72938c86ed3beadb385f29bc2954c8ca3aa47ab/spring-boot-starter-1.5.2.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter-tomcat/1.5.2.RELEASE/354320ef371fc4fc126d1bb8564cd73085a48823/spring-boot-starter-tomcat-1.5.2.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.ext/jersey-bean-validation/2.25.1/1971927d79cad0ad2b5a3bfda24967748a2023d/jersey-bean-validation-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.ext/jersey-spring3/2.25.1/a31bfcd2fcae5beb979d3f41079b6f4020d6fbc9/jersey-spring3-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2/2.5.0-b32/c3accae585955e49c771d464899e906ecc9ffb4/hk2-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/config-types/2.5.0-b32/686bbe7f80b1b879d64c06bc6606c97721a795f2/config-types-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-config/2.5.0-b32/dce05ac4225dbc0c1c382ad02e3b5bee51f0168a/hk2-config-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.hibernate/hibernate-validator/5.3.4.Final/2f6c8c0b646afe18e3ad205726729d3c4a85fe2e/hibernate-validator-5.3.4.Final.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-webmvc/4.3.7.RELEASE/d25b11a605589f176e3ecf1dcae62a991a18b377/spring-webmvc-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-web/4.3.7.RELEASE/7b69fc68cdb74c1c92f72905af6995696fcb56aa/spring-web-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.containers/jersey-container-servlet/2.25.1/cf5f7a76fcea38158b890ab7a0142d4db709a882/jersey-container-servlet-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.containers/jersey-container-servlet-core/2.25.1/400e30bb035a0cdf3c554530224141ce659a0d1e/jersey-container-servlet-core-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.core/jersey-server/2.25.1/276e2ee0fd1cdabf99357fce560c5baab675b1a2/jersey-server-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml.jackson.core/jackson-annotations/2.8.0/45b426f7796b741035581a176744d91090e2e6fb/jackson-annotations-2.8.0.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-reflect/1.0.3/ed9cbaeb8dccd2027348185044012aac145a5c61/kotlin-reflect-1.0.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-autoconfigure/1.5.2.RELEASE/8a9b8c747bc2c86eefde10330cb2984541bcb9d1/spring-boot-autoconfigure-1.5.2.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot/1.5.2.RELEASE/46bb5d8c9ab5d3ef9e158ca5906ee7d3569befc1/spring-boot-1.5.2.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework.boot/spring-boot-starter-logging/1.5.2.RELEASE/32210889e1f9bb09ac134b9f43a117ed62f0bed2/spring-boot-starter-logging-1.5.2.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/spring-bridge/2.5.0-b32/f38ecef23edc769942a95c062efd63541044de42/spring-bridge-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-context/4.3.7.RELEASE/34b66b0b7910122ef95ba4fff6da9238ef80a5de/spring-context-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-aop/4.3.7.RELEASE/3f243d685e4a8a78a0c291445c6d85560ec4d339/spring-aop-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-beans/4.3.7.RELEASE/2de9f59f3202965438f3a02057d6ad8274636044/spring-beans-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-expression/4.3.7.RELEASE/5257b6486e43d8c05674323fea5b415d4da72f38/spring-expression-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.springframework/spring-core/4.3.7.RELEASE/54fa2db94cc7222edc90ec71354e47cd1dc07f7b/spring-core-4.3.7.RELEASE.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.apache.tomcat.embed/tomcat-embed-websocket/8.5.11/dfa65e7857d46630761c0571758a56f7cbd1e9ba/tomcat-embed-websocket-8.5.11.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.apache.tomcat.embed/tomcat-embed-core/8.5.11/72761f51fc7cef3ee19d4aafc7adc605df9f611f/tomcat-embed-core-8.5.11.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.yaml/snakeyaml/1.17/7a27ea250c5130b2922b86dea63cbb1cc10a660c/snakeyaml-1.17.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.apache.tomcat.embed/tomcat-embed-el/8.5.11/60253815b897166903bf5ec41219c5bb15333a69/tomcat-embed-el-8.5.11.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/javax.validation/validation-api/1.1.0.Final/8613ae82954779d518631e05daa73a6a954817d5/validation-api-1.1.0.Final.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.jboss.logging/jboss-logging/3.3.0.Final/3616bb87707910296e2c195dc016287080bba5af/jboss-logging-3.3.0.Final.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/com.fasterxml/classmate/1.3.3/864c8e370a691e343210cc7c532fc198cee460d8/classmate-1.3.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.core/jersey-client/2.25.1/4d563b1f93352ee9fad597e9e1daf2c6159993c6/jersey-client-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.media/jersey-media-jaxb/2.25.1/d7da0beeed5614a3bfd882662faec602699e24b/jersey-media-jaxb-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.core/jersey-common/2.25.1/2438ce68d4907046095ab54aa83a6092951b4bbb/jersey-common-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.ext/jersey-entity-filtering/2.25.1/4a5805060f796ec2c9bb1ba0ce91c1db6d889524/jersey-entity-filtering-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/javax.ws.rs/javax.ws.rs-api/2.0.1/104e9c2b5583cfcfeac0402316221648d6d8ea6b/javax.ws.rs-api-2.0.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/javax.annotation/javax.annotation-api/1.2/479c1e06db31c432330183f5cae684163f186146/javax.annotation-api-1.2.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-core/2.5.0-b32/8cb6a8a9522ec523b7740d29f555bdbe9d936af2/hk2-core-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-runlevel/2.5.0-b32/60dc979763ea885e796cba4d3e322af8d500ba74/hk2-runlevel-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-locator/2.5.0-b32/195474f8ad0a8d130e9ea949a771bcf1215fc33b/hk2-locator-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-api/2.5.0-b32/6a576c9653832ce610b80a2f389374ef19d96171/hk2-api-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2.external/javax.inject/2.5.0-b32/b2fa50c8186a38728c35fe6a9da57ce4cc806923/javax.inject-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.0.3/20738122b53399036c321eeb84687367757d622a/kotlin-stdlib-1.0.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.1.11/ccedfbacef4a6515d2983e3f89ed753d5d4fb665/logback-classic-1.1.11.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.slf4j/jcl-over-slf4j/1.7.24/e6a8629079856a2aa7862c6327ccf6dd1988d7fc/jcl-over-slf4j-1.7.24.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.slf4j/jul-to-slf4j/1.7.24/25a2be668cb2ad1d05d76c0773df73b4b53617fd/jul-to-slf4j-1.7.24.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.slf4j/log4j-over-slf4j/1.7.24/6ab46c51a3848286a0db3ba7b22037b3834c3c44/log4j-over-slf4j-1.7.24.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.jersey.bundles.repackaged/jersey-guava/2.25.1/a2bb4f8208e134cf2cf71dfb8824e42942f7bd06/jersey-guava-2.25.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/osgi-resource-locator/1.0.1/4ed2b2d4738aed5786cfa64cba5a332779c4c708/osgi-resource-locator-1.0.1.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/hk2-utils/2.5.0-b32/5108a926988c4ceda7f1e681dddfe3101454a002/hk2-utils-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2.external/aopalliance-repackaged/2.5.0-b32/6af37c3f8ec6f9e9653ec837eb508da28ce443cd/aopalliance-repackaged-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.javassist/javassist/3.21.0-GA/598244f595db5c5fb713731eddbb1c91a58d959b/javassist-3.21.0-GA.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2/class-model/2.5.0-b32/17f054f3e91898c0c0fc52163ad904b13c24e8b/class-model-2.5.0-b32.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-runtime/1.0.3/10f40d016700cf4287e49fa1d51c2a8507e9b946/kotlin-runtime-1.0.3.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.1.11/88b8df40340eed549fb07e2613879bf6b006704d/logback-core-1.1.11.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/1.7.24/3f6b4bd4f8dbe8d4bea06d107a3826469b85c3e9/slf4j-api-1.7.24.jar:/home/ivark/.gradle/caches/modules-2/files-2.1/org.glassfish.hk2.external/asm-all-repackaged/2.5.0-b32/dc705f1d54cd5a96cbc5a473525e75ef1cb59a9e/asm-all-repackaged-2.5.0-b32.jar ivark.diycomputer.model.Computer
NON-BUS-IO signals:
--------------------
PC.CNT (active HIGH)
PC.LOWOUT (active LOW)
PC.JMP.COND.0 (active LOW)
PC.JMP.COND.1 (active LOW)
PC.JMP.COND.2 (active LOW)
PC.JMP.COND.3 (active LOW)
MAR.INC (active HIGH)
INSTREG.CONT (active LOW)
ALU.INVB (active HIGH)
ALU.OP0 (active LOW)
ALU.OP1 (active LOW)
ALU.OP2 (active LOW)
ALU.CS (active HIGH)
ALU.CC (active HIGH)
ALU.FLAGW (active HIGH)
SP.HIGHOUT (active HIGH)
SP.CNT (active LOW)
SP.DIRUP (active LOW)
SP.RESET (active LOW)
CLK.A.RESET (active HIGH)

RAM Write check:
Instruction set:
-----------------
Instruction #00 (0)
Instruction: LDX (X := arg)
Pattern    : LDX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> X_IN]	PC.CNT
5	INSTREG.CONT


Instruction #01 (1)
Instruction: LDX (X := ram(arg))
Pattern    : LDX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> X_IN]
8	INSTREG.CONT


Instruction #02 (2)
Instruction: STX (X -> ram(arg))
Pattern    : STX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> RAM_IN]
8	INSTREG.CONT


Instruction #03 (3)
Instruction: ADDX (X := X + arg)
Pattern    : ADDX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #04 (4)
Instruction: SUBX (X := X - arg)
Pattern    : SUBX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #05 (5)
Instruction: CMPX (flags := cmp(X,arg))
Pattern    : CMPX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	ALU.CS, PC.CNT
5	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #06 (6)
Instruction: ADDX (X := X + ram(arg))
Pattern    : ADDX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #07 (7)
Instruction: SUBX (X := X - ram(arg))
Pattern    : SUBX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
10	INSTREG.CONT


Instruction #08 (8)
Instruction: CMPX (flags := cmp(X,ram(arg)))
Pattern    : CMPX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]	ALU.CS
9	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
10	INSTREG.CONT


Instruction #09 (9)
Instruction: ANDX (X := X AND arg)
Pattern    : ANDX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> X_IN]	ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #0a (10)
Instruction: ORX (X := X OR arg)
Pattern    : ORX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #0b (11)
Instruction: XORX (X := X XOR arg)
Pattern    : XORX #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> X_IN]	ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #0c (12)
Instruction: ANDX (X := X AND ram(arg))
Pattern    : ANDX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> X_IN]	ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #0d (13)
Instruction: ORX (X := X OR ram(arg))
Pattern    : ORX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #0e (14)
Instruction: XORX (X := X XOR ram(arg))
Pattern    : XORX \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[X_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> X_IN]	ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #0f (15)
Instruction: ROLX (X := ROL(X))
Pattern    : ROLX
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.FLAGW
5	INSTREG.CONT


Instruction #10 (16)
Instruction: RORX (X := ROR(X))
Pattern    : RORX
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_B_IN]
4	BUS[ALU_OUT --> X_IN]	ALU.OP1, ALU.FLAGW
5	INSTREG.CONT


Instruction #11 (17)
Instruction: NOTX (X := NOT(X))
Pattern    : NOTX
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_B_IN]
4	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.FLAGW
5	INSTREG.CONT


Instruction #12 (18)
Instruction: ADDXY (X := X ADD Y)
Pattern    : ADDX Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Y_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #13 (19)
Instruction: SUBXY (X := X SUB Y)
Pattern    : SUBX Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Y_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #14 (20)
Instruction: ANDXY (X := X AND Y)
Pattern    : ANDX Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Y_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #15 (21)
Instruction: ORXY (X := X OR Y)
Pattern    : ORX Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Y_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #16 (22)
Instruction: XORXY (X := X XOR Y)
Pattern    : XORX Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Y_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #17 (23)
Instruction: ADDXZ (X := X ADD Z)
Pattern    : ADDX Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #18 (24)
Instruction: SUBXZ (X := X SUB Z)
Pattern    : SUBX Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #19 (25)
Instruction: ANDXZ (X := X AND Z)
Pattern    : ANDX Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #1a (26)
Instruction: ORXZ (X := X OR Z)
Pattern    : ORX Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #1b (27)
Instruction: XORXZ (X := X XOR Z)
Pattern    : XORX Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #1c (28)
Instruction: INCX (X := X + 1 )
Pattern    : INC X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> ALU_B_IN]
4	BUS[X_OUT --> ALU_A_IN]	ALU.CS
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #1d (29)
Instruction: DECX (X := X - 1 )
Pattern    : DEC X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> ALU_B_IN]
4	BUS[X_OUT --> ALU_A_IN]	ALU.CC
5	BUS[ALU_OUT --> X_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #1e (30)
Instruction: LDY (Y := arg)
Pattern    : LDY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> Y_IN]	PC.CNT
5	INSTREG.CONT


Instruction #1f (31)
Instruction: LDY (Y := ram(arg))
Pattern    : LDY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> Y_IN]
8	INSTREG.CONT


Instruction #20 (32)
Instruction: STY (Y -> ram(arg))
Pattern    : STY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> RAM_IN]
8	INSTREG.CONT


Instruction #21 (33)
Instruction: ADDY (Y := Y + arg)
Pattern    : ADDY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #22 (34)
Instruction: SUBY (Y := Y - arg)
Pattern    : SUBY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #23 (35)
Instruction: CMPY (flags := cmp(Y,arg))
Pattern    : CMPY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	ALU.CS, PC.CNT
5	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #24 (36)
Instruction: ADDY (Y := Y + ram(arg))
Pattern    : ADDY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #25 (37)
Instruction: SUBY (Y := Y - ram(arg))
Pattern    : SUBY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
10	INSTREG.CONT


Instruction #26 (38)
Instruction: CMPY (flags := cmp(Y,ram(arg)))
Pattern    : CMPY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]	ALU.CS
9	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
10	INSTREG.CONT


Instruction #27 (39)
Instruction: ANDY (Y := Y AND arg)
Pattern    : ANDY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Y_IN]	ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #28 (40)
Instruction: ORY (Y := Y OR arg)
Pattern    : ORY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #29 (41)
Instruction: XORY (Y := Y XOR arg)
Pattern    : XORY #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Y_IN]	ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #2a (42)
Instruction: ANDY (Y := Y AND ram(arg))
Pattern    : ANDY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Y_IN]	ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #2b (43)
Instruction: ORY (Y := Y OR ram(arg))
Pattern    : ORY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #2c (44)
Instruction: XORY (Y := Y XOR ram(arg))
Pattern    : XORY \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Y_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Y_IN]	ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #2d (45)
Instruction: ROLY (Y := ROL(Y))
Pattern    : ROLY
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.FLAGW
5	INSTREG.CONT


Instruction #2e (46)
Instruction: RORY (Y := ROR(Y))
Pattern    : RORY
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_B_IN]
4	BUS[ALU_OUT --> Y_IN]	ALU.OP1, ALU.FLAGW
5	INSTREG.CONT


Instruction #2f (47)
Instruction: NOTY (Y := NOT(Y))
Pattern    : NOTY
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_B_IN]
4	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.FLAGW
5	INSTREG.CONT


Instruction #30 (48)
Instruction: ADDYX (Y := Y ADD X)
Pattern    : ADDY X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[X_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #31 (49)
Instruction: SUBYX (Y := Y SUB X)
Pattern    : SUBY X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[X_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #32 (50)
Instruction: ANDYX (Y := Y AND X)
Pattern    : ANDY X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[X_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #33 (51)
Instruction: ORYX (Y := Y OR X)
Pattern    : ORY X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[X_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #34 (52)
Instruction: XORYX (Y := Y XOR X)
Pattern    : XORY X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[X_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #35 (53)
Instruction: ADDYZ (Y := Y ADD Z)
Pattern    : ADDY Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #36 (54)
Instruction: SUBYZ (Y := Y SUB Z)
Pattern    : SUBY Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #37 (55)
Instruction: ANDYZ (Y := Y AND Z)
Pattern    : ANDY Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #38 (56)
Instruction: ORYZ (Y := Y OR Z)
Pattern    : ORY Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #39 (57)
Instruction: XORYZ (Y := Y XOR Z)
Pattern    : XORY Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #3a (58)
Instruction: INCY (Y := Y + 1 )
Pattern    : INC Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> ALU_B_IN]
4	BUS[Y_OUT --> ALU_A_IN]	ALU.CS
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #3b (59)
Instruction: DECY (Y := Y - 1 )
Pattern    : DEC Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> ALU_B_IN]
4	BUS[Y_OUT --> ALU_A_IN]	ALU.CC
5	BUS[ALU_OUT --> Y_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #3c (60)
Instruction: LDZ (Z := arg)
Pattern    : LDZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> Z_IN]	PC.CNT
5	INSTREG.CONT


Instruction #3d (61)
Instruction: LDZ (Z := ram(arg))
Pattern    : LDZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> Z_IN]
8	INSTREG.CONT


Instruction #3e (62)
Instruction: STZ (Z -> ram(arg))
Pattern    : STZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> RAM_IN]
8	INSTREG.CONT


Instruction #3f (63)
Instruction: ADDZ (Z := Z + arg)
Pattern    : ADDZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #40 (64)
Instruction: SUBZ (Z := Z - arg)
Pattern    : SUBZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #41 (65)
Instruction: CMPZ (flags := cmp(Z,arg))
Pattern    : CMPZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	ALU.CS, PC.CNT
5	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #42 (66)
Instruction: ADDZ (Z := Z + ram(arg))
Pattern    : ADDZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #43 (67)
Instruction: SUBZ (Z := Z - ram(arg))
Pattern    : SUBZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
10	INSTREG.CONT


Instruction #44 (68)
Instruction: CMPZ (flags := cmp(Z,ram(arg)))
Pattern    : CMPZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]	ALU.CS
9	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
10	INSTREG.CONT


Instruction #45 (69)
Instruction: ANDZ (Z := Z AND arg)
Pattern    : ANDZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Z_IN]	ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #46 (70)
Instruction: ORZ (Z := Z OR arg)
Pattern    : ORZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #47 (71)
Instruction: XORZ (Z := Z XOR arg)
Pattern    : XORZ #(..)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]	MAR.INC
4	BUS[RAM_OUT --> ALU_B_IN]	PC.CNT
5	BUS[ALU_OUT --> Z_IN]	ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #48 (72)
Instruction: ANDZ (Z := Z AND ram(arg))
Pattern    : ANDZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Z_IN]	ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #49 (73)
Instruction: ORZ (Z := Z OR ram(arg))
Pattern    : ORZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #4a (74)
Instruction: XORZ (Z := Z XOR ram(arg))
Pattern    : XORZ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[Z_OUT --> ALU_A_IN]
8	BUS[RAM_OUT --> ALU_B_IN]
9	BUS[ALU_OUT --> Z_IN]	ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #4b (75)
Instruction: ROLZ (Z := ROL(Z))
Pattern    : ROLZ
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_A_IN]
4	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.FLAGW
5	INSTREG.CONT


Instruction #4c (76)
Instruction: RORZ (Z := ROR(Z))
Pattern    : RORZ
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_B_IN]
4	BUS[ALU_OUT --> Z_IN]	ALU.OP1, ALU.FLAGW
5	INSTREG.CONT


Instruction #4d (77)
Instruction: NOTZ (Z := NOT(Z))
Pattern    : NOTZ
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Z_OUT --> ALU_B_IN]
4	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.FLAGW
5	INSTREG.CONT


Instruction #4e (78)
Instruction: INCZ (Z := Z + 1 )
Pattern    : INC Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> ALU_B_IN]
4	BUS[Z_OUT --> ALU_A_IN]	ALU.CS
5	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
6	INSTREG.CONT


Instruction #4f (79)
Instruction: DECZ (Z := Z - 1 )
Pattern    : DEC Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> ALU_B_IN]
4	BUS[Z_OUT --> ALU_A_IN]	ALU.CC
5	BUS[ALU_OUT --> Z_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #50 (80)
Instruction: CMPX (flags := cmp(X,Y))
Pattern    : CMPX,Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Y_OUT --> ALU_B_IN]	ALU.CS
5	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #51 (81)
Instruction: CMPX (flags := cmp(X,Z))
Pattern    : CMPX,Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]	ALU.CS
5	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #52 (82)
Instruction: CMPY (flags := cmp(Y,Z))
Pattern    : CMPY,Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> ALU_A_IN]
4	BUS[Z_OUT --> ALU_B_IN]	ALU.CS
5	BUS[NO_OUTPUT --> NO_INPUT]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW, ALU.INVB
6	INSTREG.CONT


Instruction #53 (83)
Instruction: NOP (No operation)
Pattern    : NOP
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	INSTREG.CONT


Instruction #54 (84)
Instruction: ROR (ram(arg):=ROR(ram(arg)))
Pattern    : ROR \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> ALU_B_IN]
8	BUS[ALU_OUT --> RAM_IN]	ALU.OP1, ALU.FLAGW
9	INSTREG.CONT


Instruction #55 (85)
Instruction: ROL (ram(arg):=ROL(ram(arg)))
Pattern    : ROL \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> ALU_A_IN]
8	BUS[ALU_OUT --> RAM_IN]	ALU.OP2, ALU.OP1, ALU.FLAGW
9	INSTREG.CONT


Instruction #56 (86)
Instruction: NOT (ram(arg):=NOT(ram(arg)))
Pattern    : NOT \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> ALU_B_IN]
8	BUS[ALU_OUT --> RAM_IN]	ALU.OP2, ALU.FLAGW
9	INSTREG.CONT


Instruction #57 (87)
Instruction: INC (ram(arg):=INC(ram(arg)))
Pattern    : INC \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[NO_OUTPUT --> ALU_B_IN]
8	BUS[RAM_OUT --> ALU_A_IN]	ALU.CS
9	BUS[ALU_OUT --> RAM_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.FLAGW
10	INSTREG.CONT


Instruction #58 (88)
Instruction: DEC (ram(arg):=DEC(ram(arg)))
Pattern    : DEC \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[NO_OUTPUT --> ALU_B_IN]
8	BUS[RAM_OUT --> ALU_A_IN]	ALU.CC
9	BUS[ALU_OUT --> RAM_IN]	ALU.OP2, ALU.OP1, ALU.OP0, ALU.INVB, ALU.FLAGW
10	INSTREG.CONT


Instruction #59 (89)
Instruction: SEC (flags.c=true)
Pattern    : SEC
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	ALU.CS
4	INSTREG.CONT


Instruction #5a (90)
Instruction: CLC (flags.c=false)
Pattern    : CLC
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	ALU.CC
4	INSTREG.CONT


Instruction #5b (91)
Instruction: JMP (if (true) pc=arg)
Pattern    : JMP \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #5c (92)
Instruction: BEQ (if (z==1) pc=arg)
Pattern    : BEQ \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0
7	INSTREG.CONT


Instruction #5d (93)
Instruction: BNE (if (z==0) pc=arg)
Pattern    : BNE \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.1
7	INSTREG.CONT


Instruction #5e (94)
Instruction: BCS (if (c==1) pc=arg)
Pattern    : BCS \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.1
7	INSTREG.CONT


Instruction #5f (95)
Instruction: BCC (if (c==0) pc=arg)
Pattern    : BCC \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.2
7	INSTREG.CONT


Instruction #60 (96)
Instruction: BMI (if (n==1) pc=arg)
Pattern    : BMI \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.2
7	INSTREG.CONT


Instruction #61 (97)
Instruction: BPL (if (n==0) pc=arg)
Pattern    : BPL \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.1, PC.JMP.COND.2
7	INSTREG.CONT


Instruction #62 (98)
Instruction: BVS (if (v==1) pc=arg)
Pattern    : BVS \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2
7	INSTREG.CONT


Instruction #63 (99)
Instruction: BVC (if (v==0) pc=arg)
Pattern    : BVC \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.3
7	INSTREG.CONT


Instruction #64 (100)
Instruction: BHI (if (c==1 && z==0) pc=arg)
Pattern    : BHI \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #65 (101)
Instruction: BLS (if (c==0 | z==1) pc=arg)
Pattern    : BLS \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.1, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #66 (102)
Instruction: BGE (if (n==v) pc=arg)
Pattern    : BGE \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #67 (103)
Instruction: BLT (if (n!=v) pc=arg)
Pattern    : BLT \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.2, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #68 (104)
Instruction: BGT (if (z==0 && n==v) pc=arg)
Pattern    : BGT \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.0, PC.JMP.COND.2, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #69 (105)
Instruction: BLE (if (z==1 | n!=v) pc=arg)
Pattern    : BLE \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT
6	PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
7	INSTREG.CONT


Instruction #6a (106)
Instruction: JMP (pc=ram(arg))
Pattern    : JMP \(\$(....)\)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> PC_JMP_H_IN]	MAR.INC
8	BUS[RAM_OUT --> PC_JMP_L_IN]
9	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
10	INSTREG.CONT


Instruction #6b (107)
Instruction: JSR (if (cond) pc=address, push returnaddress)
Pattern    : JSR \$(....)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> PC_JMP_H_IN]	PC.CNT, MAR.INC, SP.CNT
5	BUS[RAM_OUT --> PC_JMP_L_IN]	PC.CNT, SP.CNT
6	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
7	BUS[SP_OUT --> MAR_L_IN]
8	BUS[PC_OUT --> RAM_IN]
9	MAR.INC
10	BUS[PC_OUT --> RAM_IN]	PC.LOWOUT
11	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
12	INSTREG.CONT


Instruction #6c (108)
Instruction: JSR (if (cond) pc=ram($address), push returnaddress)
Pattern    : JSR \(\$(....)\)
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	MAR.INC
4	BUS[RAM_OUT --> TMP_IN]	MAR.INC, PC.CNT
5	BUS[RAM_OUT --> MAR_L_IN]	PC.CNT
6	BUS[TMP_OUT --> MAR_H_IN]
7	BUS[RAM_OUT --> PC_JMP_H_IN]	MAR.INC, SP.CNT
8	BUS[RAM_OUT --> PC_JMP_L_IN]	SP.CNT
9	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
10	BUS[SP_OUT --> MAR_L_IN]
11	BUS[PC_OUT --> RAM_IN]
12	MAR.INC
13	BUS[PC_OUT --> RAM_IN]	PC.LOWOUT
14	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
15	INSTREG.CONT


Instruction #6d (109)
Instruction: RTS (pc=pop())
Pattern    : RTS
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
4	BUS[SP_OUT --> MAR_L_IN]
5	BUS[RAM_OUT --> PC_JMP_H_IN]	MAR.INC, SP.CNT, SP.DIRUP
6	BUS[RAM_OUT --> PC_JMP_L_IN]	SP.CNT, SP.DIRUP
7	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
8	INSTREG.CONT


Instruction #6e (110)
Instruction: PUSHX (push(X))
Pattern    : PUSH X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	SP.CNT
4	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
5	BUS[SP_OUT --> MAR_L_IN]
6	BUS[X_OUT --> RAM_IN]
7	INSTREG.CONT


Instruction #6f (111)
Instruction: POPX (X=pop())
Pattern    : POP X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
4	BUS[SP_OUT --> MAR_L_IN]	SP.CNT, SP.DIRUP
5	BUS[RAM_OUT --> X_IN]
6	INSTREG.CONT


Instruction #70 (112)
Instruction: PUSHY (push(Y))
Pattern    : PUSH Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	SP.CNT
4	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
5	BUS[SP_OUT --> MAR_L_IN]
6	BUS[Y_OUT --> RAM_IN]
7	INSTREG.CONT


Instruction #71 (113)
Instruction: POPY (Y=pop())
Pattern    : POP Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
4	BUS[SP_OUT --> MAR_L_IN]	SP.CNT, SP.DIRUP
5	BUS[RAM_OUT --> Y_IN]
6	INSTREG.CONT


Instruction #72 (114)
Instruction: PUSHZ (push(Z))
Pattern    : PUSH Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	SP.CNT
4	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
5	BUS[SP_OUT --> MAR_L_IN]
6	BUS[Z_OUT --> RAM_IN]
7	INSTREG.CONT


Instruction #73 (115)
Instruction: POPZ (Z=pop())
Pattern    : POP Z
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[SP_OUT --> MAR_H_IN]	SP.HIGHOUT
4	BUS[SP_OUT --> MAR_L_IN]	SP.CNT, SP.DIRUP
5	BUS[RAM_OUT --> Z_IN]
6	INSTREG.CONT


Instruction #74 (116)
Instruction: HLT (halt)
Pattern    : HLT
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	CLK.A.RESET
4	INSTREG.CONT


Instruction #75 (117)
Instruction: OUT0 (out#0 := X)
Pattern    : OUT0 X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> OUTPUT_0_IN]
4	INSTREG.CONT


Instruction #76 (118)
Instruction: OUT1 (out#1 := X)
Pattern    : OUT1 X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> OUTPUT_1_IN]
4	INSTREG.CONT


Instruction #77 (119)
Instruction: OUT2 (out#2 := X)
Pattern    : OUT2 X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[X_OUT --> OUTPUT_2_IN]
4	INSTREG.CONT


Instruction #78 (120)
Instruction: OUT0 (out#0 := Y)
Pattern    : OUT0 Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> OUTPUT_0_IN]
4	INSTREG.CONT


Instruction #79 (121)
Instruction: OUT1 (out#1 := Y)
Pattern    : OUT1 Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> OUTPUT_1_IN]
4	INSTREG.CONT


Instruction #7a (122)
Instruction: OUT2 (out#2 := Y)
Pattern    : OUT2 Y
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[Y_OUT --> OUTPUT_2_IN]
4	INSTREG.CONT


Instruction #7b (123)
Instruction: IN0 (X := in#0)
Pattern    : IN0 X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[INPUT_0_OUT --> X_IN]
4	INSTREG.CONT


Instruction #7c (124)
Instruction: IN1 (X := in#1)
Pattern    : IN1 X
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[INPUT_1_OUT --> X_IN]
4	INSTREG.CONT


Instruction #7d (125)
Instruction: RAMLOAD (RAMLOAD)
Pattern    : RAMLOAD
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> MAR_H_IN]
4	BUS[NO_OUTPUT --> MAR_L_IN]
5	MAR.INC
6	BUS[NO_OUTPUT --> RAM_IN]
7	SP.RESET
8	INSTREG.CONT


Instruction #7e (126)
Instruction: RESETPC (RESETPC)
Pattern    : RESETPC
Microcode steps:
0	BUS[PC_OUT --> MAR_H_IN]
1	BUS[PC_OUT --> MAR_L_IN]	PC.LOWOUT, PC.CNT
2	BUS[RAM_OUT --> INSTREG_IN]
3	BUS[NO_OUTPUT --> TMP_IN]
4	BUS[TMP_OUT --> PC_JMP_H_IN]
5	BUS[TMP_OUT --> PC_JMP_L_IN]
6	PC.JMP.COND.0, PC.JMP.COND.1, PC.JMP.COND.2, PC.JMP.COND.3
7	INSTREG.CONT






Instruction set summary:
-------------------------
0= #00		LDX #(..)		X := arg		6
1= #01		LDX \$(....)		X := ram(arg)		9
2= #02		STX \$(....)		X -> ram(arg)		9
3= #03		ADDX #(..)		X := X + arg		7
4= #04		SUBX #(..)		X := X - arg		7
5= #05		CMPX #(..)		flags := cmp(X,arg)		7
6= #06		ADDX \$(....)		X := X + ram(arg)		11
7= #07		SUBX \$(....)		X := X - ram(arg)		11
8= #08		CMPX \$(....)		flags := cmp(X,ram(arg))		11
9= #09		ANDX #(..)		X := X AND arg		7
10= #0a		ORX #(..)		X := X OR arg		7
11= #0b		XORX #(..)		X := X XOR arg		7
12= #0c		ANDX \$(....)		X := X AND ram(arg)		11
13= #0d		ORX \$(....)		X := X OR ram(arg)		11
14= #0e		XORX \$(....)		X := X XOR ram(arg)		11
15= #0f		ROLX		X := ROL(X)		6
16= #10		RORX		X := ROR(X)		6
17= #11		NOTX		X := NOT(X)		6
18= #12		ADDX Y		X := X ADD Y		7
19= #13		SUBX Y		X := X SUB Y		7
20= #14		ANDX Y		X := X AND Y		7
21= #15		ORX Y		X := X OR Y		7
22= #16		XORX Y		X := X XOR Y		7
23= #17		ADDX Z		X := X ADD Z		7
24= #18		SUBX Z		X := X SUB Z		7
25= #19		ANDX Z		X := X AND Z		7
26= #1a		ORX Z		X := X OR Z		7
27= #1b		XORX Z		X := X XOR Z		7
28= #1c		INC X		X := X + 1 		7
29= #1d		DEC X		X := X - 1 		7
30= #1e		LDY #(..)		Y := arg		6
31= #1f		LDY \$(....)		Y := ram(arg)		9
32= #20		STY \$(....)		Y -> ram(arg)		9
33= #21		ADDY #(..)		Y := Y + arg		7
34= #22		SUBY #(..)		Y := Y - arg		7
35= #23		CMPY #(..)		flags := cmp(Y,arg)		7
36= #24		ADDY \$(....)		Y := Y + ram(arg)		11
37= #25		SUBY \$(....)		Y := Y - ram(arg)		11
38= #26		CMPY \$(....)		flags := cmp(Y,ram(arg))		11
39= #27		ANDY #(..)		Y := Y AND arg		7
40= #28		ORY #(..)		Y := Y OR arg		7
41= #29		XORY #(..)		Y := Y XOR arg		7
42= #2a		ANDY \$(....)		Y := Y AND ram(arg)		11
43= #2b		ORY \$(....)		Y := Y OR ram(arg)		11
44= #2c		XORY \$(....)		Y := Y XOR ram(arg)		11
45= #2d		ROLY		Y := ROL(Y)		6
46= #2e		RORY		Y := ROR(Y)		6
47= #2f		NOTY		Y := NOT(Y)		6
48= #30		ADDY X		Y := Y ADD X		7
49= #31		SUBY X		Y := Y SUB X		7
50= #32		ANDY X		Y := Y AND X		7
51= #33		ORY X		Y := Y OR X		7
52= #34		XORY X		Y := Y XOR X		7
53= #35		ADDY Z		Y := Y ADD Z		7
54= #36		SUBY Z		Y := Y SUB Z		7
55= #37		ANDY Z		Y := Y AND Z		7
56= #38		ORY Z		Y := Y OR Z		7
57= #39		XORY Z		Y := Y XOR Z		7
58= #3a		INC Y		Y := Y + 1 		7
59= #3b		DEC Y		Y := Y - 1 		7
60= #3c		LDZ #(..)		Z := arg		6
61= #3d		LDZ \$(....)		Z := ram(arg)		9
62= #3e		STZ \$(....)		Z -> ram(arg)		9
63= #3f		ADDZ #(..)		Z := Z + arg		7
64= #40		SUBZ #(..)		Z := Z - arg		7
65= #41		CMPZ #(..)		flags := cmp(Z,arg)		7
66= #42		ADDZ \$(....)		Z := Z + ram(arg)		11
67= #43		SUBZ \$(....)		Z := Z - ram(arg)		11
68= #44		CMPZ \$(....)		flags := cmp(Z,ram(arg))		11
69= #45		ANDZ #(..)		Z := Z AND arg		7
70= #46		ORZ #(..)		Z := Z OR arg		7
71= #47		XORZ #(..)		Z := Z XOR arg		7
72= #48		ANDZ \$(....)		Z := Z AND ram(arg)		11
73= #49		ORZ \$(....)		Z := Z OR ram(arg)		11
74= #4a		XORZ \$(....)		Z := Z XOR ram(arg)		11
75= #4b		ROLZ		Z := ROL(Z)		6
76= #4c		RORZ		Z := ROR(Z)		6
77= #4d		NOTZ		Z := NOT(Z)		6
78= #4e		INC Z		Z := Z + 1 		7
79= #4f		DEC Z		Z := Z - 1 		7
80= #50		CMPX,Y		flags := cmp(X,Y)		7
81= #51		CMPX,Z		flags := cmp(X,Z)		7
82= #52		CMPY,Z		flags := cmp(Y,Z)		7
83= #53		NOP		No operation		4
84= #54		ROR \$(....)		ram(arg):=ROR(ram(arg))		10
85= #55		ROL \$(....)		ram(arg):=ROL(ram(arg))		10
86= #56		NOT \$(....)		ram(arg):=NOT(ram(arg))		10
87= #57		INC \$(....)		ram(arg):=INC(ram(arg))		11
88= #58		DEC \$(....)		ram(arg):=DEC(ram(arg))		11
89= #59		SEC		flags.c=true		5
90= #5a		CLC		flags.c=false		5
91= #5b		JMP \$(....)		if (true) pc=arg		8
92= #5c		BEQ \$(....)		if (z==1) pc=arg		8
93= #5d		BNE \$(....)		if (z==0) pc=arg		8
94= #5e		BCS \$(....)		if (c==1) pc=arg		8
95= #5f		BCC \$(....)		if (c==0) pc=arg		8
96= #60		BMI \$(....)		if (n==1) pc=arg		8
97= #61		BPL \$(....)		if (n==0) pc=arg		8
98= #62		BVS \$(....)		if (v==1) pc=arg		8
99= #63		BVC \$(....)		if (v==0) pc=arg		8
100= #64		BHI \$(....)		if (c==1 && z==0) pc=arg		8
101= #65		BLS \$(....)		if (c==0 | z==1) pc=arg		8
102= #66		BGE \$(....)		if (n==v) pc=arg		8
103= #67		BLT \$(....)		if (n!=v) pc=arg		8
104= #68		BGT \$(....)		if (z==0 && n==v) pc=arg		8
105= #69		BLE \$(....)		if (z==1 | n!=v) pc=arg		8
106= #6a		JMP \(\$(....)\)		pc=ram(arg)		11
107= #6b		JSR \$(....)		if (cond) pc=address, push returnaddress		13
108= #6c		JSR \(\$(....)\)		if (cond) pc=ram($address), push returnaddress		16
109= #6d		RTS		pc=pop()		9
110= #6e		PUSH X		push(X)		8
111= #6f		POP X		X=pop()		7
112= #70		PUSH Y		push(Y)		8
113= #71		POP Y		Y=pop()		7
114= #72		PUSH Z		push(Z)		8
115= #73		POP Z		Z=pop()		7
116= #74		HLT		halt		5
117= #75		OUT0 X		out#0 := X		5
118= #76		OUT1 X		out#1 := X		5
119= #77		OUT2 X		out#2 := X		5
120= #78		OUT0 Y		out#0 := Y		5
121= #79		OUT1 Y		out#1 := Y		5
122= #7a		OUT2 Y		out#2 := Y		5
123= #7b		IN0 X		X := in#0		5
124= #7c		IN1 X		X := in#1		5
125= #7d		RAMLOAD		RAMLOAD		9
126= #7e		RESETPC		RESETPC		8


Process finished with exit code 0
